// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.common

import cats.data.NonEmptyList
import cats.effect.IO
import clue.GraphQLOperation
import clue.annotation.GraphQL
import clue.data.Input
import explore.AppCtx
import explore.components.graphql.LiveQueryRenderMod
import explore.data.KeyedIndexedList
import explore.implicits._
import explore.model.AirMassRange
import explore.model.ConstraintsSummary
import explore.model.ObsSummary
import explore.model.reusability._
import explore.schemas.ObservationDB
import explore.schemas.ObservationDB.Types._
import japgolly.scalajs.react._
import japgolly.scalajs.react.vdom.html_<^._
import lucuma.core.model.ConstraintSet
import lucuma.core.model.Observation
import lucuma.ui.reusability._
import monocle.Getter
import monocle.macros.Lenses

object ConstraintSetObsQueries {

  type ConstraintSetList = KeyedIndexedList[ConstraintSet.Id, ConstraintsSummary]
  type ObsList           = KeyedIndexedList[Observation.Id, ObsSummary]

  def defaultCreateConstraintSet(
    cs: ConstraintsSummary
  ): CreateConstraintSetInput =
    CreateConstraintSetInput(
      constraintSetId = Input(cs.id),
      programId = "p-2",
      name = cs.name,
      imageQuality = cs.imageQuality,
      cloudExtinction = cs.cloudExtinction,
      skyBackground = cs.skyBackground,
      waterVapor = cs.waterVapor,
      elevationRange = CreateElevationRangeInput(airmassRange =
        clue.data.Input(
          CreateAirmassRangeInput(min = AirMassRange.DefaultMin.value,
                                  max = AirMassRange.DefaultMax.value
          )
        )
      )
    )

  @Lenses
  case class ConstraintSetsWithObs(constraintSets: ConstraintSetList, obs: ObsList)

  @GraphQL
  trait ConstraintSetsObsQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query {
        constraintSets(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
            imageQuality
            cloudExtinction
            skyBackground
            waterVapor
          }
        }

        observations(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
            observationTarget {
              type: __typename
              ... on Target {
                target_id: id
                target_name: name
              }
              ... on Asterism {
                asterism_id: id
                asterism_name: name
              }
            }
            constraintSet {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
        }
      }
    """

    object Data {
      object ConstraintSets {
        type Nodes = ConstraintsSummary
      }

      object Observations {
        type Nodes = ObsSummary
      }
    }
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ConstraintSetsObsQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query {
          constraintSets(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
  
          observations(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
              observationTarget {
                type: __typename
                ... on Target {
                  target_id: id
                  target_name: name
                }
                ... on Asterism {
                  asterism_id: id
                  asterism_name: name
                }
              }
              constraintSet {
                id
                name
                imageQuality
                cloudExtinction
                skyBackground
                waterVapor
              }
            }
          }
        }
      """
    object Data {
      object ConstraintSets {
        type Nodes = ConstraintsSummary
        implicit val nodes: monocle.Lens[Data.ConstraintSets, List[Data.ConstraintSets.Nodes]] = monocle.macros.GenLens[Data.ConstraintSets](_.nodes)
        implicit val eqConstraintSets: cats.Eq[Data.ConstraintSets] = cats.Eq.fromUniversalEquals
        implicit val showConstraintSets: cats.Show[Data.ConstraintSets] = cats.Show.fromToString
        implicit val reuseConstraintSets: japgolly.scalajs.react.Reusability[Data.ConstraintSets] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderConstraintSets: io.circe.Decoder[Data.ConstraintSets] = io.circe.generic.semiauto.deriveDecoder[Data.ConstraintSets]
      }
      object Observations {
        type Nodes = ObsSummary
        implicit val nodes: monocle.Lens[Data.Observations, List[Data.Observations.Nodes]] = monocle.macros.GenLens[Data.Observations](_.nodes)
        implicit val eqObservations: cats.Eq[Data.Observations] = cats.Eq.fromUniversalEquals
        implicit val showObservations: cats.Show[Data.Observations] = cats.Show.fromToString
        implicit val reuseObservations: japgolly.scalajs.react.Reusability[Data.Observations] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservations: io.circe.Decoder[Data.Observations] = io.circe.generic.semiauto.deriveDecoder[Data.Observations]
      }
      case class ConstraintSets(val nodes: List[Data.ConstraintSets.Nodes])
      case class Observations(val nodes: List[Data.Observations.Nodes])
      implicit val constraintSets: monocle.Lens[Data, Data.ConstraintSets] = monocle.macros.GenLens[Data](_.constraintSets)
      implicit val observations: monocle.Lens[Data, Data.Observations] = monocle.macros.GenLens[Data](_.observations)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val constraintSets: Data.ConstraintSets, val observations: Data.Observations)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]]()(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  private val constraintSetsObsQueryConstraintSetsWithObsGetter
    : Getter[ConstraintSetsObsQuery.Data, ConstraintSetsWithObs] = data => {
    ConstraintSetsWithObs(
      KeyedIndexedList.fromList(data.constraintSets.nodes, ConstraintsSummary.id.get),
      KeyedIndexedList.fromList(data.observations.nodes, ObsSummary.id.get)
    )
  }

  implicit class ConstraintSetsObsQueryDataOps(val self: ConstraintSetsObsQuery.Data.type)
      extends AnyVal {
    def asConstraintSetsWithObs = constraintSetsObsQueryConstraintSetsWithObsGetter
  }

  @GraphQL
  trait ConstraintSetEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        constraintSetEdit(programId: "p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ConstraintSetEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          constraintSetEdit(programId: "p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val constraintSetEdit: Data.ConstraintSetEdit)
    object Data {
      case class ConstraintSetEdit(val id: Long)
      object ConstraintSetEdit {
        implicit val id: monocle.Lens[Data.ConstraintSetEdit, Long] = monocle.macros.GenLens[Data.ConstraintSetEdit](_.id)
        implicit val eqConstraintSetEdit: cats.Eq[Data.ConstraintSetEdit] = cats.Eq.fromUniversalEquals
        implicit val showConstraintSetEdit: cats.Show[Data.ConstraintSetEdit] = cats.Show.fromToString
        implicit val reuseConstraintSetEdit: japgolly.scalajs.react.Reusability[Data.ConstraintSetEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderConstraintSetEdit: io.circe.Decoder[Data.ConstraintSetEdit] = io.circe.generic.semiauto.deriveDecoder[Data.ConstraintSetEdit]
      }
      implicit val constraintSetEdit: monocle.Lens[Data, Data.ConstraintSetEdit] = monocle.macros.GenLens[Data](_.constraintSetEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AddConstraintSetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($input: CreateConstraintSetInput!) {
        createConstraintSet(input: $input) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AddConstraintSet extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($input: CreateConstraintSetInput!) {
          createConstraintSet(input: $input) {
            id
          }
        }
      """
    case class Variables(val input: CreateConstraintSetInput)
    object Variables {
      implicit val input: monocle.Lens[Variables, CreateConstraintSetInput] = monocle.macros.GenLens[Variables](_.input)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createConstraintSet: Option[Data.CreateConstraintSet] = None)
    object Data {
      case class CreateConstraintSet(val id: ConstraintSetId)
      object CreateConstraintSet {
        implicit val id: monocle.Lens[Data.CreateConstraintSet, ConstraintSetId] = monocle.macros.GenLens[Data.CreateConstraintSet](_.id)
        implicit val eqCreateConstraintSet: cats.Eq[Data.CreateConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showCreateConstraintSet: cats.Show[Data.CreateConstraintSet] = cats.Show.fromToString
        implicit val reuseCreateConstraintSet: japgolly.scalajs.react.Reusability[Data.CreateConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateConstraintSet: io.circe.Decoder[Data.CreateConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.CreateConstraintSet]
      }
      implicit val createConstraintSet: monocle.Lens[Data, Option[Data.CreateConstraintSet]] = monocle.macros.GenLens[Data](_.createConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](input: CreateConstraintSetInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(input))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait DeleteConstraintSetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($constraintSetId: ConstraintSetId!) {
        deleteConstraintSet(constraintSetId: $constraintSetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object DeleteConstraintSet extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($constraintSetId: ConstraintSetId!) {
          deleteConstraintSet(constraintSetId: $constraintSetId) {
            id
          }
        }
      """
    case class Variables(val constraintSetId: ConstraintSetId)
    object Variables {
      implicit val constraintSetId: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.constraintSetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteConstraintSet: Data.DeleteConstraintSet)
    object Data {
      case class DeleteConstraintSet(val id: ConstraintSetId)
      object DeleteConstraintSet {
        implicit val id: monocle.Lens[Data.DeleteConstraintSet, ConstraintSetId] = monocle.macros.GenLens[Data.DeleteConstraintSet](_.id)
        implicit val eqDeleteConstraintSet: cats.Eq[Data.DeleteConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showDeleteConstraintSet: cats.Show[Data.DeleteConstraintSet] = cats.Show.fromToString
        implicit val reuseDeleteConstraintSet: japgolly.scalajs.react.Reusability[Data.DeleteConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteConstraintSet: io.circe.Decoder[Data.DeleteConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteConstraintSet]
      }
      implicit val deleteConstraintSet: monocle.Lens[Data, Data.DeleteConstraintSet] = monocle.macros.GenLens[Data](_.deleteConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](constraintSetId: ConstraintSetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(constraintSetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UndeleteConstraintSetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($constraintSetId: ConstraintSetId!) {
        undeleteContraintSet(constraintSetId: $constraintSetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UndeleteConstraintSet extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($constraintSetId: ConstraintSetId!) {
          undeleteContraintSet(constraintSetId: $constraintSetId) {
            id
          }
        }
      """
    case class Variables(val constraintSetId: ConstraintSetId)
    object Variables {
      implicit val constraintSetId: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.constraintSetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteContraintSet: Data.UndeleteContraintSet)
    object Data {
      case class UndeleteContraintSet(val id: ConstraintSetId)
      object UndeleteContraintSet {
        implicit val id: monocle.Lens[Data.UndeleteContraintSet, ConstraintSetId] = monocle.macros.GenLens[Data.UndeleteContraintSet](_.id)
        implicit val eqUndeleteContraintSet: cats.Eq[Data.UndeleteContraintSet] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteContraintSet: cats.Show[Data.UndeleteContraintSet] = cats.Show.fromToString
        implicit val reuseUndeleteContraintSet: japgolly.scalajs.react.Reusability[Data.UndeleteContraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteContraintSet: io.circe.Decoder[Data.UndeleteContraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteContraintSet]
      }
      implicit val undeleteContraintSet: monocle.Lens[Data, Data.UndeleteContraintSet] = monocle.macros.GenLens[Data](_.undeleteContraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](constraintSetId: ConstraintSetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(constraintSetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AssignConstraintSetToObsGQL extends GraphQLOperation[ObservationDB] {
    val document: String = """
      mutation($constraintSetId: ConstraintSetId!, $obsId: ObservationId!) {
        updateObservationConstraintSet(
          input: { constraintSetId: $constraintSetId, observationIds: [$obsId] }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AssignConstraintSetToObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document: String = """
        mutation($constraintSetId: ConstraintSetId!, $obsId: ObservationId!) {
          updateObservationConstraintSet(
            input: { constraintSetId: $constraintSetId, observationIds: [$obsId] }
          ) {
            id
          }
        }
      """
    case class Variables(val constraintSetId: ConstraintSetId, val obsId: ObservationId)
    object Variables {
      implicit val constraintSetId: monocle.Lens[Variables, ConstraintSetId] = monocle.macros.GenLens[Variables](_.constraintSetId)
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservationConstraintSet: List[Data.UpdateObservationConstraintSet])
    object Data {
      case class UpdateObservationConstraintSet(val id: ObservationId)
      object UpdateObservationConstraintSet {
        implicit val id: monocle.Lens[Data.UpdateObservationConstraintSet, ObservationId] = monocle.macros.GenLens[Data.UpdateObservationConstraintSet](_.id)
        implicit val eqUpdateObservationConstraintSet: cats.Eq[Data.UpdateObservationConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservationConstraintSet: cats.Show[Data.UpdateObservationConstraintSet] = cats.Show.fromToString
        implicit val reuseUpdateObservationConstraintSet: japgolly.scalajs.react.Reusability[Data.UpdateObservationConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservationConstraintSet: io.circe.Decoder[Data.UpdateObservationConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservationConstraintSet]
      }
      implicit val updateObservationConstraintSet: monocle.Lens[Data, List[Data.UpdateObservationConstraintSet]] = monocle.macros.GenLens[Data](_.updateObservationConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](constraintSetId: ConstraintSetId, obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(constraintSetId, obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UnassignConstraintSetFromObsGQL extends GraphQLOperation[ObservationDB] {
    val document: String = """
      mutation($obsId: ObservationId!) {
        updateObservationConstraintSet(
          input: { observationIds: [$obsId], constraintSetId: null }
         ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UnassignConstraintSetFromObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document: String = """
        mutation($obsId: ObservationId!) {
          updateObservationConstraintSet(
            input: { observationIds: [$obsId], constraintSetId: null }
           ) {
            id
          }
        }
      """
    case class Variables(val obsId: ObservationId)
    object Variables {
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservationConstraintSet: List[Data.UpdateObservationConstraintSet])
    object Data {
      case class UpdateObservationConstraintSet(val id: ObservationId)
      object UpdateObservationConstraintSet {
        implicit val id: monocle.Lens[Data.UpdateObservationConstraintSet, ObservationId] = monocle.macros.GenLens[Data.UpdateObservationConstraintSet](_.id)
        implicit val eqUpdateObservationConstraintSet: cats.Eq[Data.UpdateObservationConstraintSet] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservationConstraintSet: cats.Show[Data.UpdateObservationConstraintSet] = cats.Show.fromToString
        implicit val reuseUpdateObservationConstraintSet: japgolly.scalajs.react.Reusability[Data.UpdateObservationConstraintSet] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservationConstraintSet: io.circe.Decoder[Data.UpdateObservationConstraintSet] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservationConstraintSet]
      }
      implicit val updateObservationConstraintSet: monocle.Lens[Data, List[Data.UpdateObservationConstraintSet]] = monocle.macros.GenLens[Data](_.updateObservationConstraintSet)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  implicit val constraintSetWithObsReusability: Reusability[ConstraintSetsWithObs] =
    Reusability.derive

  val ConstraintSetObsLiveQuery =
    ScalaFnComponent[View[ConstraintSetsWithObs] => VdomNode](render =>
      AppCtx.using { implicit appCtx =>
        LiveQueryRenderMod[ObservationDB, ConstraintSetsObsQuery.Data, ConstraintSetsWithObs](
          ConstraintSetsObsQuery.query(),
          ConstraintSetsObsQuery.Data.asConstraintSetsWithObs.get,
          NonEmptyList.of(
            ConstraintSetEditSubscription.subscribe[IO](),
            ObsQueries.ProgramObservationsEditSubscription.subscribe[IO]()
          )
        )(render)
      }
    )

}
