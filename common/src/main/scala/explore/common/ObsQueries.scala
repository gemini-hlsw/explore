// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.common

import cats.data.NonEmptyList
import cats.effect.IO
import clue.GraphQLOperation
import clue.annotation.GraphQL
import explore.AppCtx
import explore.components.graphql.LiveQueryRenderMod
import explore.data.KeyedIndexedList
import explore.implicits._
import explore.model.ObsSummary
import explore.model.reusability._
import explore.schemas.ObservationDB
import japgolly.scalajs.react._
import japgolly.scalajs.react.vdom.html_<^._
import lucuma.core.model.Observation
import lucuma.ui.reusability._
import monocle.Getter

object ObsQueries {

  type ObservationList = KeyedIndexedList[Observation.Id, ObsSummary]

  @GraphQL
  trait ProgramObservationsQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query {
        observations(programId: "p-2", first: 2147483647) {
          nodes {
            id
            observationTarget {
              type: __typename
              ... on Target {
                target_id: id
                target_name: name
              }
              ... on Asterism {
                asterism_id: id
                asterism_name: name
              }
            }
            constraintSet {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
        }
      }
    """

    object Data {
      object Observations {
        type Nodes = ObsSummary
      }
    }
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramObservationsQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query {
          observations(programId: "p-2", first: 2147483647) {
            nodes {
              id
              observationTarget {
                type: __typename
                ... on Target {
                  target_id: id
                  target_name: name
                }
                ... on Asterism {
                  asterism_id: id
                  asterism_name: name
                }
              }
              constraintSet {
                id
                name
                imageQuality
                cloudExtinction
                skyBackground
                waterVapor
              }
            }
          }
        }
      """
    object Data {
      object Observations {
        type Nodes = ObsSummary
        implicit val nodes: monocle.Lens[Data.Observations, List[Data.Observations.Nodes]] = monocle.macros.GenLens[Data.Observations](_.nodes)
        implicit val eqObservations: cats.Eq[Data.Observations] = cats.Eq.fromUniversalEquals
        implicit val showObservations: cats.Show[Data.Observations] = cats.Show.fromToString
        implicit val reuseObservations: japgolly.scalajs.react.Reusability[Data.Observations] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservations: io.circe.Decoder[Data.Observations] = io.circe.generic.semiauto.deriveDecoder[Data.Observations]
      }
      case class Observations(val nodes: List[Data.Observations.Nodes])
      implicit val observations: monocle.Lens[Data, Data.Observations] = monocle.macros.GenLens[Data](_.observations)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val observations: Data.Observations)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]]()(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  private val programObservationsQueryoObservationListGetter
    : Getter[ProgramObservationsQuery.Data, ObservationList] =
    data => KeyedIndexedList.fromList(data.observations.nodes, ObsSummary.id.get)
  implicit class ProgramObservationsQueryDataOps(val self: ProgramObservationsQuery.Data.type)
      extends AnyVal {
    def asObservationList = programObservationsQueryoObservationListGetter
  }

  @GraphQL
  trait ProgramObservationsEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        observationEdit(programId:"p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramObservationsEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          observationEdit(programId:"p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val observationEdit: Data.ObservationEdit)
    object Data {
      case class ObservationEdit(val id: Long)
      object ObservationEdit {
        implicit val id: monocle.Lens[Data.ObservationEdit, Long] = monocle.macros.GenLens[Data.ObservationEdit](_.id)
        implicit val eqObservationEdit: cats.Eq[Data.ObservationEdit] = cats.Eq.fromUniversalEquals
        implicit val showObservationEdit: cats.Show[Data.ObservationEdit] = cats.Show.fromToString
        implicit val reuseObservationEdit: japgolly.scalajs.react.Reusability[Data.ObservationEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservationEdit: io.circe.Decoder[Data.ObservationEdit] = io.circe.generic.semiauto.deriveDecoder[Data.ObservationEdit]
      }
      implicit val observationEdit: monocle.Lens[Data, Data.ObservationEdit] = monocle.macros.GenLens[Data](_.observationEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  val ObsLiveQuery =
    ScalaFnComponent[View[ObservationList] => VdomNode](render =>
      AppCtx.using { implicit appCtx =>
        LiveQueryRenderMod[ObservationDB, ProgramObservationsQuery.Data, ObservationList](
          ProgramObservationsQuery.query(),
          ProgramObservationsQuery.Data.asObservationList.get,
          NonEmptyList.of(
            ProgramObservationsEditSubscription.subscribe[IO](),
            ConstraintSetObsQueries.ConstraintSetEditSubscription.subscribe[IO]()
          )
        )(render)
      }
    )

  @GraphQL
  trait ProgramCreateObservationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($createObservation: CreateObservationInput!) {
        createObservation(input: $createObservation) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramCreateObservation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($createObservation: CreateObservationInput!) {
          createObservation(input: $createObservation) {
            id
          }
        }
      """
    case class Variables(val createObservation: CreateObservationInput)
    object Variables {
      implicit val createObservation: monocle.Lens[Variables, CreateObservationInput] = monocle.macros.GenLens[Variables](_.createObservation)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createObservation: Option[Data.CreateObservation] = None)
    object Data {
      case class CreateObservation(val id: ObservationId)
      object CreateObservation {
        implicit val id: monocle.Lens[Data.CreateObservation, ObservationId] = monocle.macros.GenLens[Data.CreateObservation](_.id)
        implicit val eqCreateObservation: cats.Eq[Data.CreateObservation] = cats.Eq.fromUniversalEquals
        implicit val showCreateObservation: cats.Show[Data.CreateObservation] = cats.Show.fromToString
        implicit val reuseCreateObservation: japgolly.scalajs.react.Reusability[Data.CreateObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateObservation: io.circe.Decoder[Data.CreateObservation] = io.circe.generic.semiauto.deriveDecoder[Data.CreateObservation]
      }
      implicit val createObservation: monocle.Lens[Data, Option[Data.CreateObservation]] = monocle.macros.GenLens[Data](_.createObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](createObservation: CreateObservationInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(createObservation))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait ProgramDeleteObservationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($oid: ObservationId!) {
        deleteObservation(observationId: $oid) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramDeleteObservation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($oid: ObservationId!) {
          deleteObservation(observationId: $oid) {
            id
          }
        }
      """
    case class Variables(val oid: ObservationId)
    object Variables {
      implicit val oid: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.oid)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteObservation: Data.DeleteObservation)
    object Data {
      case class DeleteObservation(val id: ObservationId)
      object DeleteObservation {
        implicit val id: monocle.Lens[Data.DeleteObservation, ObservationId] = monocle.macros.GenLens[Data.DeleteObservation](_.id)
        implicit val eqDeleteObservation: cats.Eq[Data.DeleteObservation] = cats.Eq.fromUniversalEquals
        implicit val showDeleteObservation: cats.Show[Data.DeleteObservation] = cats.Show.fromToString
        implicit val reuseDeleteObservation: japgolly.scalajs.react.Reusability[Data.DeleteObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteObservation: io.circe.Decoder[Data.DeleteObservation] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteObservation]
      }
      implicit val deleteObservation: monocle.Lens[Data, Data.DeleteObservation] = monocle.macros.GenLens[Data](_.deleteObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](oid: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(oid))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait ProgramUndeleteObservationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($oid: ObservationId!) {
        undeleteObservation(observationId: $oid) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ProgramUndeleteObservation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($oid: ObservationId!) {
          undeleteObservation(observationId: $oid) {
            id
          }
        }
      """
    case class Variables(val oid: ObservationId)
    object Variables {
      implicit val oid: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.oid)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteObservation: Data.UndeleteObservation)
    object Data {
      case class UndeleteObservation(val id: ObservationId)
      object UndeleteObservation {
        implicit val id: monocle.Lens[Data.UndeleteObservation, ObservationId] = monocle.macros.GenLens[Data.UndeleteObservation](_.id)
        implicit val eqUndeleteObservation: cats.Eq[Data.UndeleteObservation] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteObservation: cats.Show[Data.UndeleteObservation] = cats.Show.fromToString
        implicit val reuseUndeleteObservation: japgolly.scalajs.react.Reusability[Data.UndeleteObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteObservation: io.circe.Decoder[Data.UndeleteObservation] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteObservation]
      }
      implicit val undeleteObservation: monocle.Lens[Data, Data.UndeleteObservation] = monocle.macros.GenLens[Data](_.undeleteObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](oid: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(oid))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */
}
