// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.common

import cats.data.NonEmptyList
import cats.effect.IO
import clue.GraphQLOperation
import clue.annotation.GraphQL
import eu.timepit.refined.types.string.NonEmptyString
import explore.AppCtx
import explore.components.graphql.LiveQueryRenderMod
import explore.data.KeyedIndexedList
import explore.implicits._
import explore.model.ObsSummary
import explore.model.reusability._
import explore.schemas.ObservationDB
import io.circe.Decoder
import io.circe.HCursor
import io.circe.generic.semiauto._
import io.circe.refined._
import japgolly.scalajs.react._
import japgolly.scalajs.react.vdom.html_<^._
import lucuma.core.model.Asterism
import lucuma.core.model.Observation
import lucuma.core.model.Target
import lucuma.ui.reusability._
import monocle.Getter
import monocle.macros.Lenses

object TargetObsQueries {

  @Lenses
  case class TargetIdName(id: Target.Id, name: NonEmptyString)
  object TargetIdName {
    implicit val decoder: Decoder[TargetIdName] = deriveDecoder
  }

  @Lenses
  case class AsterismIdName(
    id:      Asterism.Id,
    name:    NonEmptyString,
    targets: TargetList
  )
  object AsterismIdName {
    implicit val decoder: Decoder[AsterismIdName] = new Decoder[AsterismIdName] {
      final def apply(c: HCursor): Decoder.Result[AsterismIdName] =
        for {
          id      <- c.downField("id").as[Asterism.Id]
          name    <- c.downField("name").as[NonEmptyString]
          targets <- c.downField("targets").downField("nodes").as[List[TargetIdName]]
        } yield AsterismIdName(id, name, KeyedIndexedList.fromList(targets, TargetIdName.id.get))
    }
  }

  type TargetList   = KeyedIndexedList[Target.Id, TargetIdName]
  type AsterismList = KeyedIndexedList[Asterism.Id, AsterismIdName]
  type ObsList      = KeyedIndexedList[Observation.Id, ObsSummary]

  @Lenses
  case class TargetsAndAsterismsWithObs(
    targets:      TargetList,
    asterisms:    AsterismList,
    observations: ObsList
  )

  @GraphQL
  trait TargetsObsQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query {
        targets(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
          }
        }

        asterisms(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
            targets(first: 2147483647) {
              nodes {
                id
                name
              }
            }
          }
        }

        observations(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
            observationTarget {
              type: __typename
              ... on Target {
                target_id: id
                target_name: name
              }
              ... on Asterism {
                asterism_id: id
                asterism_name: name
              }
            }
            constraintSet {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
        }
      }
    """

    object Data {
      object Targets {
        type Nodes = TargetIdName
      }

      object Asterisms {
        type Nodes = AsterismIdName
      }

      object Observations {
        type Nodes = ObsSummary
      }
    }
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object TargetsObsQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query {
          targets(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
            }
          }
  
          asterisms(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
              targets(first: 2147483647) {
                nodes {
                  id
                  name
                }
              }
            }
          }
  
          observations(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
              observationTarget {
                type: __typename
                ... on Target {
                  target_id: id
                  target_name: name
                }
                ... on Asterism {
                  asterism_id: id
                  asterism_name: name
                }
              }
              constraintSet {
                id
                name
                imageQuality
                cloudExtinction
                skyBackground
                waterVapor
              }
            }
          }
        }
      """
    object Data {
      object Targets {
        type Nodes = TargetIdName
        implicit val nodes: monocle.Lens[Data.Targets, List[Data.Targets.Nodes]] = monocle.macros.GenLens[Data.Targets](_.nodes)
        implicit val eqTargets: cats.Eq[Data.Targets] = cats.Eq.fromUniversalEquals
        implicit val showTargets: cats.Show[Data.Targets] = cats.Show.fromToString
        implicit val reuseTargets: japgolly.scalajs.react.Reusability[Data.Targets] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderTargets: io.circe.Decoder[Data.Targets] = io.circe.generic.semiauto.deriveDecoder[Data.Targets]
      }
      object Asterisms {
        type Nodes = AsterismIdName
        implicit val nodes: monocle.Lens[Data.Asterisms, List[Data.Asterisms.Nodes]] = monocle.macros.GenLens[Data.Asterisms](_.nodes)
        implicit val eqAsterisms: cats.Eq[Data.Asterisms] = cats.Eq.fromUniversalEquals
        implicit val showAsterisms: cats.Show[Data.Asterisms] = cats.Show.fromToString
        implicit val reuseAsterisms: japgolly.scalajs.react.Reusability[Data.Asterisms] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderAsterisms: io.circe.Decoder[Data.Asterisms] = io.circe.generic.semiauto.deriveDecoder[Data.Asterisms]
      }
      object Observations {
        type Nodes = ObsSummary
        implicit val nodes: monocle.Lens[Data.Observations, List[Data.Observations.Nodes]] = monocle.macros.GenLens[Data.Observations](_.nodes)
        implicit val eqObservations: cats.Eq[Data.Observations] = cats.Eq.fromUniversalEquals
        implicit val showObservations: cats.Show[Data.Observations] = cats.Show.fromToString
        implicit val reuseObservations: japgolly.scalajs.react.Reusability[Data.Observations] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservations: io.circe.Decoder[Data.Observations] = io.circe.generic.semiauto.deriveDecoder[Data.Observations]
      }
      case class Targets(val nodes: List[Data.Targets.Nodes])
      case class Asterisms(val nodes: List[Data.Asterisms.Nodes])
      case class Observations(val nodes: List[Data.Observations.Nodes])
      implicit val targets: monocle.Lens[Data, Data.Targets] = monocle.macros.GenLens[Data](_.targets)
      implicit val asterisms: monocle.Lens[Data, Data.Asterisms] = monocle.macros.GenLens[Data](_.asterisms)
      implicit val observations: monocle.Lens[Data, Data.Observations] = monocle.macros.GenLens[Data](_.observations)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val targets: Data.Targets, val asterisms: Data.Asterisms, val observations: Data.Observations)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]]()(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  private val targetsObsQueryTargetsWithObsGetter
    : Getter[TargetsObsQuery.Data, TargetsAndAsterismsWithObs] =
    data => {
      TargetsAndAsterismsWithObs(
        KeyedIndexedList.fromList(data.targets.nodes, TargetIdName.id.get),
        KeyedIndexedList.fromList(data.asterisms.nodes, AsterismIdName.id.get),
        KeyedIndexedList.fromList(data.observations.nodes, ObsSummary.id.get)
      )
    }

  implicit class TargetsObsQueryDataOps(val self: TargetsObsQuery.Data.type) extends AnyVal {
    def asTargetsWithObs = targetsObsQueryTargetsWithObsGetter
  }

  @GraphQL
  trait TargetEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        targetEdit(programId: "p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object TargetEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          targetEdit(programId: "p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val targetEdit: Data.TargetEdit)
    object Data {
      case class TargetEdit(val id: Long)
      object TargetEdit {
        implicit val id: monocle.Lens[Data.TargetEdit, Long] = monocle.macros.GenLens[Data.TargetEdit](_.id)
        implicit val eqTargetEdit: cats.Eq[Data.TargetEdit] = cats.Eq.fromUniversalEquals
        implicit val showTargetEdit: cats.Show[Data.TargetEdit] = cats.Show.fromToString
        implicit val reuseTargetEdit: japgolly.scalajs.react.Reusability[Data.TargetEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderTargetEdit: io.circe.Decoder[Data.TargetEdit] = io.circe.generic.semiauto.deriveDecoder[Data.TargetEdit]
      }
      implicit val targetEdit: monocle.Lens[Data, Data.TargetEdit] = monocle.macros.GenLens[Data](_.targetEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AsterismEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        asterismEdit(programId: "p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AsterismEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          asterismEdit(programId: "p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val asterismEdit: Data.AsterismEdit)
    object Data {
      case class AsterismEdit(val id: Long)
      object AsterismEdit {
        implicit val id: monocle.Lens[Data.AsterismEdit, Long] = monocle.macros.GenLens[Data.AsterismEdit](_.id)
        implicit val eqAsterismEdit: cats.Eq[Data.AsterismEdit] = cats.Eq.fromUniversalEquals
        implicit val showAsterismEdit: cats.Show[Data.AsterismEdit] = cats.Show.fromToString
        implicit val reuseAsterismEdit: japgolly.scalajs.react.Reusability[Data.AsterismEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderAsterismEdit: io.circe.Decoder[Data.AsterismEdit] = io.circe.generic.semiauto.deriveDecoder[Data.AsterismEdit]
      }
      implicit val asterismEdit: monocle.Lens[Data, Data.AsterismEdit] = monocle.macros.GenLens[Data](_.asterismEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UpdateObservationMutationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($input: EditObservationInput!) {
        updateObservation(input: $input) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UpdateObservationMutation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($input: EditObservationInput!) {
          updateObservation(input: $input) {
            id
          }
        }
      """
    case class Variables(val input: EditObservationInput)
    object Variables {
      implicit val input: monocle.Lens[Variables, EditObservationInput] = monocle.macros.GenLens[Variables](_.input)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservation: Data.UpdateObservation)
    object Data {
      case class UpdateObservation(val id: ObservationId)
      object UpdateObservation {
        implicit val id: monocle.Lens[Data.UpdateObservation, ObservationId] = monocle.macros.GenLens[Data.UpdateObservation](_.id)
        implicit val eqUpdateObservation: cats.Eq[Data.UpdateObservation] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservation: cats.Show[Data.UpdateObservation] = cats.Show.fromToString
        implicit val reuseUpdateObservation: japgolly.scalajs.react.Reusability[Data.UpdateObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservation: io.circe.Decoder[Data.UpdateObservation] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservation]
      }
      implicit val updateObservation: monocle.Lens[Data, Data.UpdateObservation] = monocle.macros.GenLens[Data](_.updateObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](input: EditObservationInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(input))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AddTargetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $name: NonEmptyString!) {
        createSiderealTarget(input:{
          targetId: $targetId,
          name: $name,
          programIds: ["p-2"],
          ra: {microarcseconds: 0},
          dec: {microarcseconds: 0}
        }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AddTarget extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $name: NonEmptyString!) {
          createSiderealTarget(input:{
            targetId: $targetId,
            name: $name,
            programIds: ["p-2"],
            ra: {microarcseconds: 0},
            dec: {microarcseconds: 0}
          }) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val name: NonEmptyString)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val name: monocle.Lens[Variables, NonEmptyString] = monocle.macros.GenLens[Variables](_.name)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createSiderealTarget: Option[Data.CreateSiderealTarget] = None)
    object Data {
      case class CreateSiderealTarget(val id: TargetId)
      object CreateSiderealTarget {
        implicit val id: monocle.Lens[Data.CreateSiderealTarget, TargetId] = monocle.macros.GenLens[Data.CreateSiderealTarget](_.id)
        implicit val eqCreateSiderealTarget: cats.Eq[Data.CreateSiderealTarget] = cats.Eq.fromUniversalEquals
        implicit val showCreateSiderealTarget: cats.Show[Data.CreateSiderealTarget] = cats.Show.fromToString
        implicit val reuseCreateSiderealTarget: japgolly.scalajs.react.Reusability[Data.CreateSiderealTarget] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateSiderealTarget: io.circe.Decoder[Data.CreateSiderealTarget] = io.circe.generic.semiauto.deriveDecoder[Data.CreateSiderealTarget]
      }
      implicit val createSiderealTarget: monocle.Lens[Data, Option[Data.CreateSiderealTarget]] = monocle.macros.GenLens[Data](_.createSiderealTarget)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, name: NonEmptyString)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, name))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait RemoveTargetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!) {
        deleteTarget(targetId: $targetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object RemoveTarget extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!) {
          deleteTarget(targetId: $targetId) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteTarget: Data.DeleteTarget)
    object Data {
      case class DeleteTarget(val id: TargetId)
      object DeleteTarget {
        implicit val id: monocle.Lens[Data.DeleteTarget, TargetId] = monocle.macros.GenLens[Data.DeleteTarget](_.id)
        implicit val eqDeleteTarget: cats.Eq[Data.DeleteTarget] = cats.Eq.fromUniversalEquals
        implicit val showDeleteTarget: cats.Show[Data.DeleteTarget] = cats.Show.fromToString
        implicit val reuseDeleteTarget: japgolly.scalajs.react.Reusability[Data.DeleteTarget] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteTarget: io.circe.Decoder[Data.DeleteTarget] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteTarget]
      }
      implicit val deleteTarget: monocle.Lens[Data, Data.DeleteTarget] = monocle.macros.GenLens[Data](_.deleteTarget)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UndeleteTargetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!) {
        undeleteTarget(targetId: $targetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UndeleteTarget extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!) {
          undeleteTarget(targetId: $targetId) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteTarget: Data.UndeleteTarget)
    object Data {
      case class UndeleteTarget(val id: TargetId)
      object UndeleteTarget {
        implicit val id: monocle.Lens[Data.UndeleteTarget, TargetId] = monocle.macros.GenLens[Data.UndeleteTarget](_.id)
        implicit val eqUndeleteTarget: cats.Eq[Data.UndeleteTarget] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteTarget: cats.Show[Data.UndeleteTarget] = cats.Show.fromToString
        implicit val reuseUndeleteTarget: japgolly.scalajs.react.Reusability[Data.UndeleteTarget] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteTarget: io.circe.Decoder[Data.UndeleteTarget] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteTarget]
      }
      implicit val undeleteTarget: monocle.Lens[Data, Data.UndeleteTarget] = monocle.macros.GenLens[Data](_.undeleteTarget)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AddAsterismGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!, $name: NonEmptyString!) {
        createAsterism(input:{
          asterismId: $asterismId,
          name: $name,
          programIds: ["p-2"]
        }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AddAsterism extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!, $name: NonEmptyString!) {
          createAsterism(input:{
            asterismId: $asterismId,
            name: $name,
            programIds: ["p-2"]
          }) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId, val name: NonEmptyString)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val name: monocle.Lens[Variables, NonEmptyString] = monocle.macros.GenLens[Variables](_.name)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createAsterism: Option[Data.CreateAsterism] = None)
    object Data {
      case class CreateAsterism(val id: AsterismId)
      object CreateAsterism {
        implicit val id: monocle.Lens[Data.CreateAsterism, AsterismId] = monocle.macros.GenLens[Data.CreateAsterism](_.id)
        implicit val eqCreateAsterism: cats.Eq[Data.CreateAsterism] = cats.Eq.fromUniversalEquals
        implicit val showCreateAsterism: cats.Show[Data.CreateAsterism] = cats.Show.fromToString
        implicit val reuseCreateAsterism: japgolly.scalajs.react.Reusability[Data.CreateAsterism] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateAsterism: io.circe.Decoder[Data.CreateAsterism] = io.circe.generic.semiauto.deriveDecoder[Data.CreateAsterism]
      }
      implicit val createAsterism: monocle.Lens[Data, Option[Data.CreateAsterism]] = monocle.macros.GenLens[Data](_.createAsterism)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId, name: NonEmptyString)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId, name))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait RemoveAsterismGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!) {
        deleteAsterism(asterismId: $asterismId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object RemoveAsterism extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!) {
          deleteAsterism(asterismId: $asterismId) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteAsterism: Data.DeleteAsterism)
    object Data {
      case class DeleteAsterism(val id: AsterismId)
      object DeleteAsterism {
        implicit val id: monocle.Lens[Data.DeleteAsterism, AsterismId] = monocle.macros.GenLens[Data.DeleteAsterism](_.id)
        implicit val eqDeleteAsterism: cats.Eq[Data.DeleteAsterism] = cats.Eq.fromUniversalEquals
        implicit val showDeleteAsterism: cats.Show[Data.DeleteAsterism] = cats.Show.fromToString
        implicit val reuseDeleteAsterism: japgolly.scalajs.react.Reusability[Data.DeleteAsterism] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteAsterism: io.circe.Decoder[Data.DeleteAsterism] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteAsterism]
      }
      implicit val deleteAsterism: monocle.Lens[Data, Data.DeleteAsterism] = monocle.macros.GenLens[Data](_.deleteAsterism)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UndeleteAsterismGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!) {
        undeleteAsterism(asterismId: $asterismId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UndeleteAsterism extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!) {
          undeleteAsterism(asterismId: $asterismId) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteAsterism: Data.UndeleteAsterism)
    object Data {
      case class UndeleteAsterism(val id: AsterismId)
      object UndeleteAsterism {
        implicit val id: monocle.Lens[Data.UndeleteAsterism, AsterismId] = monocle.macros.GenLens[Data.UndeleteAsterism](_.id)
        implicit val eqUndeleteAsterism: cats.Eq[Data.UndeleteAsterism] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteAsterism: cats.Show[Data.UndeleteAsterism] = cats.Show.fromToString
        implicit val reuseUndeleteAsterism: japgolly.scalajs.react.Reusability[Data.UndeleteAsterism] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteAsterism: io.circe.Decoder[Data.UndeleteAsterism] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteAsterism]
      }
      implicit val undeleteAsterism: monocle.Lens[Data, Data.UndeleteAsterism] = monocle.macros.GenLens[Data](_.undeleteAsterism)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AssignTargetToObsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $obsId: ObservationId!) {
        updatePointing(
          input: { targetId: $targetId, observationIds: [$obsId] }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AssignTargetToObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $obsId: ObservationId!) {
          updatePointing(
            input: { targetId: $targetId, observationIds: [$obsId] }
          ) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val obsId: ObservationId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updatePointing: List[Data.UpdatePointing])
    object Data {
      case class UpdatePointing(val id: ObservationId)
      object UpdatePointing {
        implicit val id: monocle.Lens[Data.UpdatePointing, ObservationId] = monocle.macros.GenLens[Data.UpdatePointing](_.id)
        implicit val eqUpdatePointing: cats.Eq[Data.UpdatePointing] = cats.Eq.fromUniversalEquals
        implicit val showUpdatePointing: cats.Show[Data.UpdatePointing] = cats.Show.fromToString
        implicit val reuseUpdatePointing: japgolly.scalajs.react.Reusability[Data.UpdatePointing] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdatePointing: io.circe.Decoder[Data.UpdatePointing] = io.circe.generic.semiauto.deriveDecoder[Data.UpdatePointing]
      }
      implicit val updatePointing: monocle.Lens[Data, List[Data.UpdatePointing]] = monocle.macros.GenLens[Data](_.updatePointing)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AssignAsterismToObsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!, $obsId: ObservationId!) {
        updatePointing(
          input: { asterismId: $asterismId, observationIds: [$obsId] }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AssignAsterismToObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!, $obsId: ObservationId!) {
          updatePointing(
            input: { asterismId: $asterismId, observationIds: [$obsId] }
          ) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId, val obsId: ObservationId)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updatePointing: List[Data.UpdatePointing])
    object Data {
      case class UpdatePointing(val id: ObservationId)
      object UpdatePointing {
        implicit val id: monocle.Lens[Data.UpdatePointing, ObservationId] = monocle.macros.GenLens[Data.UpdatePointing](_.id)
        implicit val eqUpdatePointing: cats.Eq[Data.UpdatePointing] = cats.Eq.fromUniversalEquals
        implicit val showUpdatePointing: cats.Show[Data.UpdatePointing] = cats.Show.fromToString
        implicit val reuseUpdatePointing: japgolly.scalajs.react.Reusability[Data.UpdatePointing] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdatePointing: io.circe.Decoder[Data.UpdatePointing] = io.circe.generic.semiauto.deriveDecoder[Data.UpdatePointing]
      }
      implicit val updatePointing: monocle.Lens[Data, List[Data.UpdatePointing]] = monocle.macros.GenLens[Data](_.updatePointing)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId, obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId, obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UnassignObsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($obsId: ObservationId!) {
        updateObservation(
          input: { observationId: $obsId, asterismId: null, targetId: null }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UnassignObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($obsId: ObservationId!) {
          updateObservation(
            input: { observationId: $obsId, asterismId: null, targetId: null }
          ) {
            id
          }
        }
      """
    case class Variables(val obsId: ObservationId)
    object Variables {
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservation: Data.UpdateObservation)
    object Data {
      case class UpdateObservation(val id: ObservationId)
      object UpdateObservation {
        implicit val id: monocle.Lens[Data.UpdateObservation, ObservationId] = monocle.macros.GenLens[Data.UpdateObservation](_.id)
        implicit val eqUpdateObservation: cats.Eq[Data.UpdateObservation] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservation: cats.Show[Data.UpdateObservation] = cats.Show.fromToString
        implicit val reuseUpdateObservation: japgolly.scalajs.react.Reusability[Data.UpdateObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservation: io.circe.Decoder[Data.UpdateObservation] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservation]
      }
      implicit val updateObservation: monocle.Lens[Data, Data.UpdateObservation] = monocle.macros.GenLens[Data](_.updateObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait ShareTargetWithAsterismsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $asterismId: AsterismId!) {
        shareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ShareTargetWithAsterisms extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $asterismId: AsterismId!) {
          shareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val asterismId: AsterismId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val shareTargetWithAsterisms: Data.ShareTargetWithAsterisms)
    object Data {
      case class ShareTargetWithAsterisms(val id: TargetId)
      object ShareTargetWithAsterisms {
        implicit val id: monocle.Lens[Data.ShareTargetWithAsterisms, TargetId] = monocle.macros.GenLens[Data.ShareTargetWithAsterisms](_.id)
        implicit val eqShareTargetWithAsterisms: cats.Eq[Data.ShareTargetWithAsterisms] = cats.Eq.fromUniversalEquals
        implicit val showShareTargetWithAsterisms: cats.Show[Data.ShareTargetWithAsterisms] = cats.Show.fromToString
        implicit val reuseShareTargetWithAsterisms: japgolly.scalajs.react.Reusability[Data.ShareTargetWithAsterisms] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderShareTargetWithAsterisms: io.circe.Decoder[Data.ShareTargetWithAsterisms] = io.circe.generic.semiauto.deriveDecoder[Data.ShareTargetWithAsterisms]
      }
      implicit val shareTargetWithAsterisms: monocle.Lens[Data, Data.ShareTargetWithAsterisms] = monocle.macros.GenLens[Data](_.shareTargetWithAsterisms)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UnshareTargetWithAsterismsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $asterismId: AsterismId!) {
        unshareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UnshareTargetWithAsterisms extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $asterismId: AsterismId!) {
          unshareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val asterismId: AsterismId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val unshareTargetWithAsterisms: Data.UnshareTargetWithAsterisms)
    object Data {
      case class UnshareTargetWithAsterisms(val id: TargetId)
      object UnshareTargetWithAsterisms {
        implicit val id: monocle.Lens[Data.UnshareTargetWithAsterisms, TargetId] = monocle.macros.GenLens[Data.UnshareTargetWithAsterisms](_.id)
        implicit val eqUnshareTargetWithAsterisms: cats.Eq[Data.UnshareTargetWithAsterisms] = cats.Eq.fromUniversalEquals
        implicit val showUnshareTargetWithAsterisms: cats.Show[Data.UnshareTargetWithAsterisms] = cats.Show.fromToString
        implicit val reuseUnshareTargetWithAsterisms: japgolly.scalajs.react.Reusability[Data.UnshareTargetWithAsterisms] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUnshareTargetWithAsterisms: io.circe.Decoder[Data.UnshareTargetWithAsterisms] = io.circe.generic.semiauto.deriveDecoder[Data.UnshareTargetWithAsterisms]
      }
      implicit val unshareTargetWithAsterisms: monocle.Lens[Data, Data.UnshareTargetWithAsterisms] = monocle.macros.GenLens[Data](_.unshareTargetWithAsterisms)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  implicit val targetIdNameReusability: Reusability[TargetIdName]                 =
    Reusability.by(x => (x.id, x.name))
  implicit val asterismIdNameReusability: Reusability[AsterismIdName]             =
    Reusability.by(x => (x.id, x.name))
  implicit val targetsWithObsReusability: Reusability[TargetsAndAsterismsWithObs] =
    Reusability.derive

  val TargetObsLiveQuery =
    ScalaFnComponent[View[TargetsAndAsterismsWithObs] => VdomNode](render =>
      AppCtx.using { implicit appCtx =>
        LiveQueryRenderMod[ObservationDB, TargetsObsQuery.Data, TargetsAndAsterismsWithObs](
          TargetsObsQuery.query(),
          TargetsObsQuery.Data.asTargetsWithObs.get,
          NonEmptyList.of(
            TargetEditSubscription.subscribe[IO](),
            AsterismEditSubscription.subscribe[IO](),
            ObsQueries.ProgramObservationsEditSubscription.subscribe[IO](),
            ConstraintSetObsQueries.ConstraintSetEditSubscription.subscribe[IO]()
          )
        )(render)
      }
    )
}
