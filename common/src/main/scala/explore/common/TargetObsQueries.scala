// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package explore.common

import cats.data.NonEmptyList
import cats.effect.IO
import clue.GraphQLOperation
import clue.annotation.GraphQL
import eu.timepit.refined.types.string.NonEmptyString
import explore.AppCtx
import explore.components.graphql.LiveQueryRenderMod
import explore.data.KeyedIndexedList
import explore.implicits._
import explore.model.ConstraintsSummary
import explore.model.PointingId
import explore.model.reusability._
import explore.optics._
import explore.schemas.ObservationDB
import io.circe.refined._
import japgolly.scalajs.react._
import japgolly.scalajs.react.vdom.html_<^._
import lucuma.core.model.Asterism
import lucuma.core.model.Observation
import lucuma.core.model.Target
import lucuma.ui.reusability._
import monocle.Getter
import monocle.Iso
import monocle.Lens
import monocle.macros.Lenses

object TargetObsQueries {

  type TargetResult = TargetsObsQuery.Data.Targets.Nodes
  val TargetResult = TargetsObsQuery.Data.Targets.Nodes

  type AsterismResult = TargetsObsQuery.Data.Asterisms.Nodes
  val AsterismResult = TargetsObsQuery.Data.Asterisms.Nodes

  type ObsResult = TargetsObsQuery.Data.Observations.Nodes
  val ObsResult = TargetsObsQuery.Data.Observations.Nodes

  type PointingTargetResult = ObsResult.Pointing.Target
  val PointingTargetResult = ObsResult.Pointing.Target
  type PointingAsterismResult = ObsResult.Pointing.Asterism
  val PointingAsterismResult = ObsResult.Pointing.Asterism

  @Lenses
  case class AsterismIdName(
    id:      Asterism.Id,
    name:    Option[NonEmptyString],
    targets: TargetList
  )
  object AsterismIdName {
    def fromAsterismResult(asterism: AsterismResult): AsterismIdName =
      AsterismIdName(
        asterism.id,
        asterism.name,
        KeyedIndexedList.fromList(asterism.targets.nodes.map(t => TargetResult(t.id, t.name)),
                                  TargetResult.id.get
        )
      )
  }

  type TargetList   = KeyedIndexedList[Target.Id, TargetResult]
  type AsterismList = KeyedIndexedList[Asterism.Id, AsterismIdName]
  type ObsList      = KeyedIndexedList[Observation.Id, ObsResult]

  @Lenses
  case class PointingsWithObs(
    targets:      TargetList,
    asterisms:    AsterismList,
    observations: ObsList
  )

  @GraphQL
  trait TargetsObsQueryGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      query {
        targets(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
          }
        }

        asterisms(programId: "p-2", first: 2147483647) {
          nodes {
            id
            name
            targets(first: 2147483647) {
              nodes {
                id
                name
              }
            }
          }
        }

        observations(programId: "p-2", first: 2147483647) {
          nodes {
            id
            pointing: observationTarget {
              type: __typename
              ... on Target {
                targetId: id
              }
              ... on Asterism {
                asterismId: id
              }
            }
            constraintSet {
              id
              name
              imageQuality
              cloudExtinction
              skyBackground
              waterVapor
            }
          }
        }
      }
    """

    object Data {
      object Observations {
        object Nodes {
          type ConstraintSet = ConstraintsSummary
        }
      }
    }
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object TargetsObsQuery extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        query {
          targets(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
            }
          }
  
          asterisms(programId: "p-2", first: 2147483647) {
            nodes {
              id
              name
              targets(first: 2147483647) {
                nodes {
                  id
                  name
                }
              }
            }
          }
  
          observations(programId: "p-2", first: 2147483647) {
            nodes {
              id
              pointing: observationTarget {
                type: __typename
                ... on Target {
                  targetId: id
                }
                ... on Asterism {
                  asterismId: id
                }
              }
              constraintSet {
                id
                name
                imageQuality
                cloudExtinction
                skyBackground
                waterVapor
              }
            }
          }
        }
      """
    object Data {
      object Observations {
        object Nodes {
          type ConstraintSet = ConstraintsSummary
          sealed trait Pointing
          object Pointing {
            case class Target(val targetId: TargetId) extends Pointing()
            object Target {
              implicit val targetId: monocle.Lens[Data.Observations.Nodes.Pointing.Target, TargetId] = monocle.macros.GenLens[Data.Observations.Nodes.Pointing.Target](_.targetId)
              implicit val eqTarget: cats.Eq[Data.Observations.Nodes.Pointing.Target] = cats.Eq.fromUniversalEquals
              implicit val showTarget: cats.Show[Data.Observations.Nodes.Pointing.Target] = cats.Show.fromToString
              implicit val reuseTarget: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.Pointing.Target] = {
                import japgolly.scalajs.react.Reusability
                japgolly.scalajs.react.Reusability.derive
              }
              implicit val jsonDecoderTarget: io.circe.Decoder[Data.Observations.Nodes.Pointing.Target] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes.Pointing.Target]
            }
            case class Asterism(val asterismId: AsterismId) extends Pointing()
            object Asterism {
              implicit val asterismId: monocle.Lens[Data.Observations.Nodes.Pointing.Asterism, AsterismId] = monocle.macros.GenLens[Data.Observations.Nodes.Pointing.Asterism](_.asterismId)
              implicit val eqAsterism: cats.Eq[Data.Observations.Nodes.Pointing.Asterism] = cats.Eq.fromUniversalEquals
              implicit val showAsterism: cats.Show[Data.Observations.Nodes.Pointing.Asterism] = cats.Show.fromToString
              implicit val reuseAsterism: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.Pointing.Asterism] = {
                import japgolly.scalajs.react.Reusability
                japgolly.scalajs.react.Reusability.derive
              }
              implicit val jsonDecoderAsterism: io.circe.Decoder[Data.Observations.Nodes.Pointing.Asterism] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes.Pointing.Asterism]
            }
            implicit val eqPointing: cats.Eq[Data.Observations.Nodes.Pointing] = cats.Eq.fromUniversalEquals
            implicit val showPointing: cats.Show[Data.Observations.Nodes.Pointing] = cats.Show.fromToString
            implicit val reusePointing: japgolly.scalajs.react.Reusability[Data.Observations.Nodes.Pointing] = {
              import japgolly.scalajs.react.Reusability
              japgolly.scalajs.react.Reusability.derive
            }
            implicit protected val jsonConfiguration: io.circe.generic.extras.Configuration = io.circe.generic.extras.Configuration.default.withDiscriminator("type")
            implicit val jsonDecoderPointing: io.circe.Decoder[Data.Observations.Nodes.Pointing] = io.circe.generic.extras.semiauto.deriveConfiguredDecoder[Data.Observations.Nodes.Pointing]
          }
          implicit val id: monocle.Lens[Data.Observations.Nodes, ObservationId] = monocle.macros.GenLens[Data.Observations.Nodes](_.id)
          implicit val pointing: monocle.Lens[Data.Observations.Nodes, Option[Data.Observations.Nodes.Pointing]] = monocle.macros.GenLens[Data.Observations.Nodes](_.pointing)
          implicit val constraintSet: monocle.Lens[Data.Observations.Nodes, Option[Data.Observations.Nodes.ConstraintSet]] = monocle.macros.GenLens[Data.Observations.Nodes](_.constraintSet)
          implicit val eqNodes: cats.Eq[Data.Observations.Nodes] = cats.Eq.fromUniversalEquals
          implicit val showNodes: cats.Show[Data.Observations.Nodes] = cats.Show.fromToString
          implicit val reuseNodes: japgolly.scalajs.react.Reusability[Data.Observations.Nodes] = {
            import japgolly.scalajs.react.Reusability
            japgolly.scalajs.react.Reusability.derive
          }
          implicit val jsonDecoderNodes: io.circe.Decoder[Data.Observations.Nodes] = io.circe.generic.semiauto.deriveDecoder[Data.Observations.Nodes]
        }
        case class Nodes(val id: ObservationId, val pointing: Option[Data.Observations.Nodes.Pointing] = None, val constraintSet: Option[Data.Observations.Nodes.ConstraintSet] = None)
        implicit val nodes: monocle.Lens[Data.Observations, List[Data.Observations.Nodes]] = monocle.macros.GenLens[Data.Observations](_.nodes)
        implicit val eqObservations: cats.Eq[Data.Observations] = cats.Eq.fromUniversalEquals
        implicit val showObservations: cats.Show[Data.Observations] = cats.Show.fromToString
        implicit val reuseObservations: japgolly.scalajs.react.Reusability[Data.Observations] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderObservations: io.circe.Decoder[Data.Observations] = io.circe.generic.semiauto.deriveDecoder[Data.Observations]
      }
      case class Targets(val nodes: List[Data.Targets.Nodes])
      object Targets {
        case class Nodes(val id: TargetId, val name: NonEmptyString)
        object Nodes {
          implicit val id: monocle.Lens[Data.Targets.Nodes, TargetId] = monocle.macros.GenLens[Data.Targets.Nodes](_.id)
          implicit val name: monocle.Lens[Data.Targets.Nodes, NonEmptyString] = monocle.macros.GenLens[Data.Targets.Nodes](_.name)
          implicit val eqNodes: cats.Eq[Data.Targets.Nodes] = cats.Eq.fromUniversalEquals
          implicit val showNodes: cats.Show[Data.Targets.Nodes] = cats.Show.fromToString
          implicit val reuseNodes: japgolly.scalajs.react.Reusability[Data.Targets.Nodes] = {
            import japgolly.scalajs.react.Reusability
            japgolly.scalajs.react.Reusability.derive
          }
          implicit val jsonDecoderNodes: io.circe.Decoder[Data.Targets.Nodes] = io.circe.generic.semiauto.deriveDecoder[Data.Targets.Nodes]
        }
        implicit val nodes: monocle.Lens[Data.Targets, List[Data.Targets.Nodes]] = monocle.macros.GenLens[Data.Targets](_.nodes)
        implicit val eqTargets: cats.Eq[Data.Targets] = cats.Eq.fromUniversalEquals
        implicit val showTargets: cats.Show[Data.Targets] = cats.Show.fromToString
        implicit val reuseTargets: japgolly.scalajs.react.Reusability[Data.Targets] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderTargets: io.circe.Decoder[Data.Targets] = io.circe.generic.semiauto.deriveDecoder[Data.Targets]
      }
      case class Asterisms(val nodes: List[Data.Asterisms.Nodes])
      object Asterisms {
        case class Nodes(val id: AsterismId, val name: Option[NonEmptyString] = None, val targets: Data.Asterisms.Nodes.Targets)
        object Nodes {
          case class Targets(val nodes: List[Data.Asterisms.Nodes.Targets.Nodes])
          object Targets {
            case class Nodes(val id: TargetId, val name: NonEmptyString)
            object Nodes {
              implicit val id: monocle.Lens[Data.Asterisms.Nodes.Targets.Nodes, TargetId] = monocle.macros.GenLens[Data.Asterisms.Nodes.Targets.Nodes](_.id)
              implicit val name: monocle.Lens[Data.Asterisms.Nodes.Targets.Nodes, NonEmptyString] = monocle.macros.GenLens[Data.Asterisms.Nodes.Targets.Nodes](_.name)
              implicit val eqNodes: cats.Eq[Data.Asterisms.Nodes.Targets.Nodes] = cats.Eq.fromUniversalEquals
              implicit val showNodes: cats.Show[Data.Asterisms.Nodes.Targets.Nodes] = cats.Show.fromToString
              implicit val reuseNodes: japgolly.scalajs.react.Reusability[Data.Asterisms.Nodes.Targets.Nodes] = {
                import japgolly.scalajs.react.Reusability
                japgolly.scalajs.react.Reusability.derive
              }
              implicit val jsonDecoderNodes: io.circe.Decoder[Data.Asterisms.Nodes.Targets.Nodes] = io.circe.generic.semiauto.deriveDecoder[Data.Asterisms.Nodes.Targets.Nodes]
            }
            implicit val nodes: monocle.Lens[Data.Asterisms.Nodes.Targets, List[Data.Asterisms.Nodes.Targets.Nodes]] = monocle.macros.GenLens[Data.Asterisms.Nodes.Targets](_.nodes)
            implicit val eqTargets: cats.Eq[Data.Asterisms.Nodes.Targets] = cats.Eq.fromUniversalEquals
            implicit val showTargets: cats.Show[Data.Asterisms.Nodes.Targets] = cats.Show.fromToString
            implicit val reuseTargets: japgolly.scalajs.react.Reusability[Data.Asterisms.Nodes.Targets] = {
              import japgolly.scalajs.react.Reusability
              japgolly.scalajs.react.Reusability.derive
            }
            implicit val jsonDecoderTargets: io.circe.Decoder[Data.Asterisms.Nodes.Targets] = io.circe.generic.semiauto.deriveDecoder[Data.Asterisms.Nodes.Targets]
          }
          implicit val id: monocle.Lens[Data.Asterisms.Nodes, AsterismId] = monocle.macros.GenLens[Data.Asterisms.Nodes](_.id)
          implicit val name: monocle.Lens[Data.Asterisms.Nodes, Option[NonEmptyString]] = monocle.macros.GenLens[Data.Asterisms.Nodes](_.name)
          implicit val targets: monocle.Lens[Data.Asterisms.Nodes, Data.Asterisms.Nodes.Targets] = monocle.macros.GenLens[Data.Asterisms.Nodes](_.targets)
          implicit val eqNodes: cats.Eq[Data.Asterisms.Nodes] = cats.Eq.fromUniversalEquals
          implicit val showNodes: cats.Show[Data.Asterisms.Nodes] = cats.Show.fromToString
          implicit val reuseNodes: japgolly.scalajs.react.Reusability[Data.Asterisms.Nodes] = {
            import japgolly.scalajs.react.Reusability
            japgolly.scalajs.react.Reusability.derive
          }
          implicit val jsonDecoderNodes: io.circe.Decoder[Data.Asterisms.Nodes] = io.circe.generic.semiauto.deriveDecoder[Data.Asterisms.Nodes]
        }
        implicit val nodes: monocle.Lens[Data.Asterisms, List[Data.Asterisms.Nodes]] = monocle.macros.GenLens[Data.Asterisms](_.nodes)
        implicit val eqAsterisms: cats.Eq[Data.Asterisms] = cats.Eq.fromUniversalEquals
        implicit val showAsterisms: cats.Show[Data.Asterisms] = cats.Show.fromToString
        implicit val reuseAsterisms: japgolly.scalajs.react.Reusability[Data.Asterisms] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderAsterisms: io.circe.Decoder[Data.Asterisms] = io.circe.generic.semiauto.deriveDecoder[Data.Asterisms]
      }
      case class Observations(val nodes: List[Data.Observations.Nodes])
      implicit val targets: monocle.Lens[Data, Data.Targets] = monocle.macros.GenLens[Data](_.targets)
      implicit val asterisms: monocle.Lens[Data, Data.Asterisms] = monocle.macros.GenLens[Data](_.asterisms)
      implicit val observations: monocle.Lens[Data, Data.Observations] = monocle.macros.GenLens[Data](_.observations)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val targets: Data.Targets, val asterisms: Data.Asterisms, val observations: Data.Observations)
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def query[F[_]]()(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  val targetsObsQueryPointingId: Iso[ObsResult.Pointing, PointingId] =
    Iso[ObsResult.Pointing, PointingId] {
      case PointingTargetResult(id)   => PointingId.TargetId(id)
      case PointingAsterismResult(id) => PointingId.AsterismId(id)
    } {
      case PointingId.TargetId(id)   => PointingTargetResult(id)
      case PointingId.AsterismId(id) => PointingAsterismResult(id)
    }

  val targetsObsQueryObsPointingId: Lens[ObsResult, Option[PointingId]] =
    ObsResult.pointing.composeIso(optionIso(targetsObsQueryPointingId))

  private val targetsObsQueryTargetsWithObs: Getter[TargetsObsQuery.Data, PointingsWithObs] =
    data => {
      PointingsWithObs(
        KeyedIndexedList.fromList(data.targets.nodes, TargetResult.id.get),
        KeyedIndexedList.fromList(data.asterisms.nodes.map(AsterismIdName.fromAsterismResult),
                                  AsterismIdName.id.get
        ),
        KeyedIndexedList.fromList(data.observations.nodes, ObsResult.id.get)
      )
    }

  implicit class TargetsObsQueryDataOps(val self: TargetsObsQuery.Data.type) extends AnyVal {
    def asTargetsWithObs = targetsObsQueryTargetsWithObs
  }

  @GraphQL
  trait TargetEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        targetEdit(programId: "p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object TargetEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          targetEdit(programId: "p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val targetEdit: Data.TargetEdit)
    object Data {
      case class TargetEdit(val id: Long)
      object TargetEdit {
        implicit val id: monocle.Lens[Data.TargetEdit, Long] = monocle.macros.GenLens[Data.TargetEdit](_.id)
        implicit val eqTargetEdit: cats.Eq[Data.TargetEdit] = cats.Eq.fromUniversalEquals
        implicit val showTargetEdit: cats.Show[Data.TargetEdit] = cats.Show.fromToString
        implicit val reuseTargetEdit: japgolly.scalajs.react.Reusability[Data.TargetEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderTargetEdit: io.circe.Decoder[Data.TargetEdit] = io.circe.generic.semiauto.deriveDecoder[Data.TargetEdit]
      }
      implicit val targetEdit: monocle.Lens[Data, Data.TargetEdit] = monocle.macros.GenLens[Data](_.targetEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AsterismEditSubscriptionGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      subscription {
        asterismEdit(programId: "p-2") {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AsterismEditSubscription extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        subscription {
          asterismEdit(programId: "p-2") {
            id
          }
        }
      """
    case class Variables()
    object Variables {
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val asterismEdit: Data.AsterismEdit)
    object Data {
      case class AsterismEdit(val id: Long)
      object AsterismEdit {
        implicit val id: monocle.Lens[Data.AsterismEdit, Long] = monocle.macros.GenLens[Data.AsterismEdit](_.id)
        implicit val eqAsterismEdit: cats.Eq[Data.AsterismEdit] = cats.Eq.fromUniversalEquals
        implicit val showAsterismEdit: cats.Show[Data.AsterismEdit] = cats.Show.fromToString
        implicit val reuseAsterismEdit: japgolly.scalajs.react.Reusability[Data.AsterismEdit] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderAsterismEdit: io.circe.Decoder[Data.AsterismEdit] = io.circe.generic.semiauto.deriveDecoder[Data.AsterismEdit]
      }
      implicit val asterismEdit: monocle.Lens[Data, Data.AsterismEdit] = monocle.macros.GenLens[Data](_.asterismEdit)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def subscribe[F[_]]()(implicit client: clue.StreamingClient[F, ObservationDB]) = client.subscribe(this)(Variables())
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UpdateObservationMutationGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($input: EditObservationInput!) {
        updateObservation(input: $input) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UpdateObservationMutation extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($input: EditObservationInput!) {
          updateObservation(input: $input) {
            id
          }
        }
      """
    case class Variables(val input: EditObservationInput)
    object Variables {
      implicit val input: monocle.Lens[Variables, EditObservationInput] = monocle.macros.GenLens[Variables](_.input)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservation: Data.UpdateObservation)
    object Data {
      case class UpdateObservation(val id: ObservationId)
      object UpdateObservation {
        implicit val id: monocle.Lens[Data.UpdateObservation, ObservationId] = monocle.macros.GenLens[Data.UpdateObservation](_.id)
        implicit val eqUpdateObservation: cats.Eq[Data.UpdateObservation] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservation: cats.Show[Data.UpdateObservation] = cats.Show.fromToString
        implicit val reuseUpdateObservation: japgolly.scalajs.react.Reusability[Data.UpdateObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservation: io.circe.Decoder[Data.UpdateObservation] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservation]
      }
      implicit val updateObservation: monocle.Lens[Data, Data.UpdateObservation] = monocle.macros.GenLens[Data](_.updateObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](input: EditObservationInput)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(input))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AddTargetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $name: NonEmptyString!) {
        createSiderealTarget(input:{
          targetId: $targetId,
          name: $name,
          programIds: ["p-2"],
          ra: {microarcseconds: 0},
          dec: {microarcseconds: 0}
        }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AddTarget extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $name: NonEmptyString!) {
          createSiderealTarget(input:{
            targetId: $targetId,
            name: $name,
            programIds: ["p-2"],
            ra: {microarcseconds: 0},
            dec: {microarcseconds: 0}
          }) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val name: NonEmptyString)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val name: monocle.Lens[Variables, NonEmptyString] = monocle.macros.GenLens[Variables](_.name)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createSiderealTarget: Option[Data.CreateSiderealTarget] = None)
    object Data {
      case class CreateSiderealTarget(val id: TargetId)
      object CreateSiderealTarget {
        implicit val id: monocle.Lens[Data.CreateSiderealTarget, TargetId] = monocle.macros.GenLens[Data.CreateSiderealTarget](_.id)
        implicit val eqCreateSiderealTarget: cats.Eq[Data.CreateSiderealTarget] = cats.Eq.fromUniversalEquals
        implicit val showCreateSiderealTarget: cats.Show[Data.CreateSiderealTarget] = cats.Show.fromToString
        implicit val reuseCreateSiderealTarget: japgolly.scalajs.react.Reusability[Data.CreateSiderealTarget] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateSiderealTarget: io.circe.Decoder[Data.CreateSiderealTarget] = io.circe.generic.semiauto.deriveDecoder[Data.CreateSiderealTarget]
      }
      implicit val createSiderealTarget: monocle.Lens[Data, Option[Data.CreateSiderealTarget]] = monocle.macros.GenLens[Data](_.createSiderealTarget)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, name: NonEmptyString)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, name))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait RemoveTargetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!) {
        deleteTarget(targetId: $targetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object RemoveTarget extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!) {
          deleteTarget(targetId: $targetId) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteTarget: Data.DeleteTarget)
    object Data {
      case class DeleteTarget(val id: TargetId)
      object DeleteTarget {
        implicit val id: monocle.Lens[Data.DeleteTarget, TargetId] = monocle.macros.GenLens[Data.DeleteTarget](_.id)
        implicit val eqDeleteTarget: cats.Eq[Data.DeleteTarget] = cats.Eq.fromUniversalEquals
        implicit val showDeleteTarget: cats.Show[Data.DeleteTarget] = cats.Show.fromToString
        implicit val reuseDeleteTarget: japgolly.scalajs.react.Reusability[Data.DeleteTarget] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteTarget: io.circe.Decoder[Data.DeleteTarget] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteTarget]
      }
      implicit val deleteTarget: monocle.Lens[Data, Data.DeleteTarget] = monocle.macros.GenLens[Data](_.deleteTarget)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UndeleteTargetGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!) {
        undeleteTarget(targetId: $targetId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UndeleteTarget extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!) {
          undeleteTarget(targetId: $targetId) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteTarget: Data.UndeleteTarget)
    object Data {
      case class UndeleteTarget(val id: TargetId)
      object UndeleteTarget {
        implicit val id: monocle.Lens[Data.UndeleteTarget, TargetId] = monocle.macros.GenLens[Data.UndeleteTarget](_.id)
        implicit val eqUndeleteTarget: cats.Eq[Data.UndeleteTarget] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteTarget: cats.Show[Data.UndeleteTarget] = cats.Show.fromToString
        implicit val reuseUndeleteTarget: japgolly.scalajs.react.Reusability[Data.UndeleteTarget] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteTarget: io.circe.Decoder[Data.UndeleteTarget] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteTarget]
      }
      implicit val undeleteTarget: monocle.Lens[Data, Data.UndeleteTarget] = monocle.macros.GenLens[Data](_.undeleteTarget)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AddAsterismGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!, $name: NonEmptyString) {
        createAsterism(input:{
          asterismId: $asterismId,
          name: $name,
          programIds: ["p-2"]
        }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AddAsterism extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!, $name: NonEmptyString) {
          createAsterism(input:{
            asterismId: $asterismId,
            name: $name,
            programIds: ["p-2"]
          }) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId, val name: clue.data.Input[NonEmptyString] = clue.data.Ignore)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val name: monocle.Lens[Variables, clue.data.Input[NonEmptyString]] = monocle.macros.GenLens[Variables](_.name)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val createAsterism: Option[Data.CreateAsterism] = None)
    object Data {
      case class CreateAsterism(val id: AsterismId)
      object CreateAsterism {
        implicit val id: monocle.Lens[Data.CreateAsterism, AsterismId] = monocle.macros.GenLens[Data.CreateAsterism](_.id)
        implicit val eqCreateAsterism: cats.Eq[Data.CreateAsterism] = cats.Eq.fromUniversalEquals
        implicit val showCreateAsterism: cats.Show[Data.CreateAsterism] = cats.Show.fromToString
        implicit val reuseCreateAsterism: japgolly.scalajs.react.Reusability[Data.CreateAsterism] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderCreateAsterism: io.circe.Decoder[Data.CreateAsterism] = io.circe.generic.semiauto.deriveDecoder[Data.CreateAsterism]
      }
      implicit val createAsterism: monocle.Lens[Data, Option[Data.CreateAsterism]] = monocle.macros.GenLens[Data](_.createAsterism)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId, name: clue.data.Input[NonEmptyString] = clue.data.Ignore)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId, name))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait RemoveAsterismGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!) {
        deleteAsterism(asterismId: $asterismId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object RemoveAsterism extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!) {
          deleteAsterism(asterismId: $asterismId) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val deleteAsterism: Data.DeleteAsterism)
    object Data {
      case class DeleteAsterism(val id: AsterismId)
      object DeleteAsterism {
        implicit val id: monocle.Lens[Data.DeleteAsterism, AsterismId] = monocle.macros.GenLens[Data.DeleteAsterism](_.id)
        implicit val eqDeleteAsterism: cats.Eq[Data.DeleteAsterism] = cats.Eq.fromUniversalEquals
        implicit val showDeleteAsterism: cats.Show[Data.DeleteAsterism] = cats.Show.fromToString
        implicit val reuseDeleteAsterism: japgolly.scalajs.react.Reusability[Data.DeleteAsterism] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderDeleteAsterism: io.circe.Decoder[Data.DeleteAsterism] = io.circe.generic.semiauto.deriveDecoder[Data.DeleteAsterism]
      }
      implicit val deleteAsterism: monocle.Lens[Data, Data.DeleteAsterism] = monocle.macros.GenLens[Data](_.deleteAsterism)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UndeleteAsterismGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!) {
        undeleteAsterism(asterismId: $asterismId) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UndeleteAsterism extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!) {
          undeleteAsterism(asterismId: $asterismId) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val undeleteAsterism: Data.UndeleteAsterism)
    object Data {
      case class UndeleteAsterism(val id: AsterismId)
      object UndeleteAsterism {
        implicit val id: monocle.Lens[Data.UndeleteAsterism, AsterismId] = monocle.macros.GenLens[Data.UndeleteAsterism](_.id)
        implicit val eqUndeleteAsterism: cats.Eq[Data.UndeleteAsterism] = cats.Eq.fromUniversalEquals
        implicit val showUndeleteAsterism: cats.Show[Data.UndeleteAsterism] = cats.Show.fromToString
        implicit val reuseUndeleteAsterism: japgolly.scalajs.react.Reusability[Data.UndeleteAsterism] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUndeleteAsterism: io.circe.Decoder[Data.UndeleteAsterism] = io.circe.generic.semiauto.deriveDecoder[Data.UndeleteAsterism]
      }
      implicit val undeleteAsterism: monocle.Lens[Data, Data.UndeleteAsterism] = monocle.macros.GenLens[Data](_.undeleteAsterism)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AssignTargetToObsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $obsId: ObservationId!) {
        updatePointing(
          input: { targetId: $targetId, observationIds: [$obsId] }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AssignTargetToObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $obsId: ObservationId!) {
          updatePointing(
            input: { targetId: $targetId, observationIds: [$obsId] }
          ) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val obsId: ObservationId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updatePointing: List[Data.UpdatePointing])
    object Data {
      case class UpdatePointing(val id: ObservationId)
      object UpdatePointing {
        implicit val id: monocle.Lens[Data.UpdatePointing, ObservationId] = monocle.macros.GenLens[Data.UpdatePointing](_.id)
        implicit val eqUpdatePointing: cats.Eq[Data.UpdatePointing] = cats.Eq.fromUniversalEquals
        implicit val showUpdatePointing: cats.Show[Data.UpdatePointing] = cats.Show.fromToString
        implicit val reuseUpdatePointing: japgolly.scalajs.react.Reusability[Data.UpdatePointing] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdatePointing: io.circe.Decoder[Data.UpdatePointing] = io.circe.generic.semiauto.deriveDecoder[Data.UpdatePointing]
      }
      implicit val updatePointing: monocle.Lens[Data, List[Data.UpdatePointing]] = monocle.macros.GenLens[Data](_.updatePointing)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait AssignAsterismToObsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($asterismId: AsterismId!, $obsId: ObservationId!) {
        updatePointing(
          input: { asterismId: $asterismId, observationIds: [$obsId] }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object AssignAsterismToObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($asterismId: AsterismId!, $obsId: ObservationId!) {
          updatePointing(
            input: { asterismId: $asterismId, observationIds: [$obsId] }
          ) {
            id
          }
        }
      """
    case class Variables(val asterismId: AsterismId, val obsId: ObservationId)
    object Variables {
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updatePointing: List[Data.UpdatePointing])
    object Data {
      case class UpdatePointing(val id: ObservationId)
      object UpdatePointing {
        implicit val id: monocle.Lens[Data.UpdatePointing, ObservationId] = monocle.macros.GenLens[Data.UpdatePointing](_.id)
        implicit val eqUpdatePointing: cats.Eq[Data.UpdatePointing] = cats.Eq.fromUniversalEquals
        implicit val showUpdatePointing: cats.Show[Data.UpdatePointing] = cats.Show.fromToString
        implicit val reuseUpdatePointing: japgolly.scalajs.react.Reusability[Data.UpdatePointing] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdatePointing: io.circe.Decoder[Data.UpdatePointing] = io.circe.generic.semiauto.deriveDecoder[Data.UpdatePointing]
      }
      implicit val updatePointing: monocle.Lens[Data, List[Data.UpdatePointing]] = monocle.macros.GenLens[Data](_.updatePointing)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](asterismId: AsterismId, obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(asterismId, obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UnassignObsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($obsId: ObservationId!) {
        updateObservation(
          input: { observationId: $obsId, asterismId: null, targetId: null }
        ) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UnassignObs extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($obsId: ObservationId!) {
          updateObservation(
            input: { observationId: $obsId, asterismId: null, targetId: null }
          ) {
            id
          }
        }
      """
    case class Variables(val obsId: ObservationId)
    object Variables {
      implicit val obsId: monocle.Lens[Variables, ObservationId] = monocle.macros.GenLens[Variables](_.obsId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val updateObservation: Data.UpdateObservation)
    object Data {
      case class UpdateObservation(val id: ObservationId)
      object UpdateObservation {
        implicit val id: monocle.Lens[Data.UpdateObservation, ObservationId] = monocle.macros.GenLens[Data.UpdateObservation](_.id)
        implicit val eqUpdateObservation: cats.Eq[Data.UpdateObservation] = cats.Eq.fromUniversalEquals
        implicit val showUpdateObservation: cats.Show[Data.UpdateObservation] = cats.Show.fromToString
        implicit val reuseUpdateObservation: japgolly.scalajs.react.Reusability[Data.UpdateObservation] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUpdateObservation: io.circe.Decoder[Data.UpdateObservation] = io.circe.generic.semiauto.deriveDecoder[Data.UpdateObservation]
      }
      implicit val updateObservation: monocle.Lens[Data, Data.UpdateObservation] = monocle.macros.GenLens[Data](_.updateObservation)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](obsId: ObservationId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(obsId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait ShareTargetWithAsterismsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $asterismId: AsterismId!) {
        shareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object ShareTargetWithAsterisms extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $asterismId: AsterismId!) {
          shareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val asterismId: AsterismId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val shareTargetWithAsterisms: Data.ShareTargetWithAsterisms)
    object Data {
      case class ShareTargetWithAsterisms(val id: TargetId)
      object ShareTargetWithAsterisms {
        implicit val id: monocle.Lens[Data.ShareTargetWithAsterisms, TargetId] = monocle.macros.GenLens[Data.ShareTargetWithAsterisms](_.id)
        implicit val eqShareTargetWithAsterisms: cats.Eq[Data.ShareTargetWithAsterisms] = cats.Eq.fromUniversalEquals
        implicit val showShareTargetWithAsterisms: cats.Show[Data.ShareTargetWithAsterisms] = cats.Show.fromToString
        implicit val reuseShareTargetWithAsterisms: japgolly.scalajs.react.Reusability[Data.ShareTargetWithAsterisms] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderShareTargetWithAsterisms: io.circe.Decoder[Data.ShareTargetWithAsterisms] = io.circe.generic.semiauto.deriveDecoder[Data.ShareTargetWithAsterisms]
      }
      implicit val shareTargetWithAsterisms: monocle.Lens[Data, Data.ShareTargetWithAsterisms] = monocle.macros.GenLens[Data](_.shareTargetWithAsterisms)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  @GraphQL
  trait UnshareTargetWithAsterismsGQL extends GraphQLOperation[ObservationDB] {
    val document = """
      mutation($targetId: TargetId!, $asterismId: AsterismId!) {
        unshareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
          id
        }
      }
    """
  }

  /* BEGIN: Generated by clue. DO NOT remove or edit the following code or this comment. */
  // format: off
  object UnshareTargetWithAsterisms extends GraphQLOperation[ObservationDB] {
    import ObservationDB.Scalars._
    ignoreUnusedImportScalars()
    import ObservationDB.Enums._
    ignoreUnusedImportEnums()
    import ObservationDB.Types._
    ignoreUnusedImportTypes()
    val document = """
        mutation($targetId: TargetId!, $asterismId: AsterismId!) {
          unshareTargetWithAsterisms(input: { targetId: $targetId, asterismIds: [$asterismId] }) {
            id
          }
        }
      """
    case class Variables(val targetId: TargetId, val asterismId: AsterismId)
    object Variables {
      implicit val targetId: monocle.Lens[Variables, TargetId] = monocle.macros.GenLens[Variables](_.targetId)
      implicit val asterismId: monocle.Lens[Variables, AsterismId] = monocle.macros.GenLens[Variables](_.asterismId)
      implicit val eqVariables: cats.Eq[Variables] = cats.Eq.fromUniversalEquals
      implicit val showVariables: cats.Show[Variables] = cats.Show.fromToString
      implicit val jsonEncoderVariables: io.circe.Encoder[Variables] = io.circe.generic.semiauto.deriveEncoder[Variables].mapJson(_.foldWith(clue.data.Input.dropIgnoreFolder))
    }
    case class Data(val unshareTargetWithAsterisms: Data.UnshareTargetWithAsterisms)
    object Data {
      case class UnshareTargetWithAsterisms(val id: TargetId)
      object UnshareTargetWithAsterisms {
        implicit val id: monocle.Lens[Data.UnshareTargetWithAsterisms, TargetId] = monocle.macros.GenLens[Data.UnshareTargetWithAsterisms](_.id)
        implicit val eqUnshareTargetWithAsterisms: cats.Eq[Data.UnshareTargetWithAsterisms] = cats.Eq.fromUniversalEquals
        implicit val showUnshareTargetWithAsterisms: cats.Show[Data.UnshareTargetWithAsterisms] = cats.Show.fromToString
        implicit val reuseUnshareTargetWithAsterisms: japgolly.scalajs.react.Reusability[Data.UnshareTargetWithAsterisms] = {
          import japgolly.scalajs.react.Reusability
          japgolly.scalajs.react.Reusability.derive
        }
        implicit val jsonDecoderUnshareTargetWithAsterisms: io.circe.Decoder[Data.UnshareTargetWithAsterisms] = io.circe.generic.semiauto.deriveDecoder[Data.UnshareTargetWithAsterisms]
      }
      implicit val unshareTargetWithAsterisms: monocle.Lens[Data, Data.UnshareTargetWithAsterisms] = monocle.macros.GenLens[Data](_.unshareTargetWithAsterisms)
      implicit val eqData: cats.Eq[Data] = cats.Eq.fromUniversalEquals
      implicit val showData: cats.Show[Data] = cats.Show.fromToString
      implicit val reuseData: japgolly.scalajs.react.Reusability[Data] = {
        import japgolly.scalajs.react.Reusability
        japgolly.scalajs.react.Reusability.derive
      }
      implicit val jsonDecoderData: io.circe.Decoder[Data] = io.circe.generic.semiauto.deriveDecoder[Data]
    }
    val varEncoder: io.circe.Encoder[Variables] = Variables.jsonEncoderVariables
    val dataDecoder: io.circe.Decoder[Data] = Data.jsonDecoderData
    def execute[F[_]](targetId: TargetId, asterismId: AsterismId)(implicit client: clue.TransactionalClient[F, ObservationDB]) = client.request(this)(Variables(targetId, asterismId))
  }
  // format: on
  /* END: Generated by clue. Will be replaced when regenerating. */

  implicit val TargetResultReusability: Reusability[TargetResult]       =
    Reusability.by(x => (x.id, x.name))
  implicit val AsterismIdNameReusability: Reusability[AsterismIdName]   =
    Reusability.by(x => (x.id, x.name, x.targets))
  implicit val targetsWithObsReusability: Reusability[PointingsWithObs] =
    Reusability.derive

  val TargetObsLiveQuery =
    ScalaFnComponent[View[PointingsWithObs] => VdomNode](render =>
      AppCtx.using { implicit appCtx =>
        LiveQueryRenderMod[ObservationDB, TargetsObsQuery.Data, PointingsWithObs](
          TargetsObsQuery.query(),
          TargetsObsQuery.Data.asTargetsWithObs.get,
          NonEmptyList.of(
            TargetEditSubscription.subscribe[IO](),
            AsterismEditSubscription.subscribe[IO](),
            ObsQueries.ProgramObservationsEditSubscription.subscribe[IO](),
            ConstraintSetObsQueries.ConstraintSetEditSubscription.subscribe[IO]()
          )
        )(render)
      }
    )
}
